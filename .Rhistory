b1)
{
n = n_cluster * n_per_cluster
results <- data.frame(matrix(NA, nrow = N_test, ncol = (n_cov)))
if (n_cov > 0) {
colnames(results) <- paste0("beta", 1:n_cov)
} else{
stop("Covariables missing")
}
for (i in 1:N_test)
{
G <- rep(1:n_cluster, each = n_per_cluster)
if (n_cov == 0) {
Z <- matrix(0, n, 0)
} else {
Z <- matrix(runif(n * n_cov, a1, b1), ncol = n_cov)
}
df = simulate_data(
G,
Z,
prop = 0.6,
beta = c(0, 0.25, 0.12, 0.33, 0.24, 1, -0.2, -0.35),
theta = 0,
cens = TRUE,
pcens = 0.25,
tau = 0.5
)
df = data.frame(times = df$times, status = df$status, clusters = rep(1,length(G)), as.matrix(df[,4:(n_cov + 3)]))
res <- tryCatch(
Ml_CompRisk(df),
error = function(e) {
message("Erreur à l’itération ", i, " : ", e$message)
return(NULL)
}
)
if (!is.null(res)) {
if (n_cov > 0) {
results[i, 1:n_cov] <- res
}
}
cat("itération", i, " sur ", N_test, "\n")
}
return(results)
}
# M = Multi_tests(N_test = 20,n_cov = 8,n_cluster = 20,n_per_cluster = 25,a1 = 0,b1 = 1)
# m = compute_mean_mse(M, c(0, 0.25, 0.12, 0.33, 0.24, 1, -0.2, -0.35))
Multi_tests = function(N_test,
n_cov,
n_cluster,
n_per_cluster,
a1,
b1)
{
n = n_cluster * n_per_cluster
results <- data.frame(matrix(NA, nrow = N_test, ncol = (n_cov)))
if (n_cov > 0) {
colnames(results) <- paste0("beta", 1:n_cov)
} else{
stop("Covariables missing")
}
for (i in 1:N_test)
{
G <- rep(1:n_cluster, each = n_per_cluster)
if (n_cov == 0) {
Z <- matrix(0, n, 0)
} else {
Z <- matrix(runif(n * n_cov, a1, b1), ncol = n_cov)
}
df = simulate_data(
G,
Z,
prop = 0.6,
beta = c(0, 0.25, 0.12, 0.33, 0.24, 1, -0.2, -0.35),
theta = 0,
cens = TRUE,
pcens = 0.25,
tau = 0.5
)
df = data.frame(times = df$times, status = df$status, clusters = rep(1,length(G)), as.matrix(df[,4:(n_cov + 3)]))
res <- tryCatch(
Ml_CompRisk(df),
error = function(e) {
message("Erreur à l’itération ", i, " : ", e$message)
return(NULL)
}
)
if (!is.null(res)) {
if (n_cov > 0) {
results[i, 1:n_cov] <- res
}
}
cat("itération", i, " sur ", N_test, "\n")
}
return(results)
}
# M = Multi_tests(N_test = 20,n_cov = 8,n_cluster = 20,n_per_cluster = 25,a1 = 0,b1 = 1)
# m = compute_mean_mse(M, c(0, 0.25, 0.12, 0.33, 0.24, 1, -0.2, -0.35))
Multi_tests = function(N_test,
n_cov,
n_cluster,
n_per_cluster,
a1,
b1)
{
n = n_cluster * n_per_cluster
results <- data.frame(matrix(NA, nrow = N_test, ncol = (n_cov + 1)))
if (n_cov > 0) {
colnames(results) <- c(paste0("beta", 1:n_cov), "theta_hat")
} else{
colnames(results) <- "theta_hat"
}
for (i in 1:N_test)
{
G <- rep(1:n_cluster, each = n_per_cluster)
if (n_cov == 0) {
Z <- matrix(0, n, 0)
} else {
Z <- matrix(runif(n * n_cov, a1, b1), ncol = n_cov)
}
df = simulate_data(
G,
Z,
prop = 0.6,
beta = c(1,1.2),
theta = 0.2,
cens = TRUE,
pcens = 0.25,
tau = 0.5
)
ind <- which(df$status > 1)
df$status[ind] <- 1
df = data.frame(times = df$times,status = df$status,clusters = df$clusters,as.matrix(df[,4:(n_cov + 3)]))
res <- tryCatch(
Reml_Cox_frailty(df),
error = function(e) {
message("Erreur à l’itération ", i, " : ", e$message)
return(NULL)
}
)
if (!is.null(res)) {
if (n_cov > 0) {
results[i, 1:n_cov] <- res$beta
results[i, "theta_hat"] <- res$theta
} else{
results[i, "theta_hat"] <- res$theta
}
}
cat("itération", i, " sur ", N_test, "\n")
}
return(results)
}
M = Multi_tests(N_test = 200,n_cov = 2,n_cluster = 20,n_per_cluster = 15,a1 = 0,b1 = 1)
m = compute_mean_mse(M,c(1,1.2,0.2))
m
devtools::load_all()
install.packages("survival")
devtools::install("C:/Users/delbe/Total/TRAVAIL/Informatique/Stage Inria/MulticenterCompRisk")
knitr::opts_chunk$set(echo = TRUE)
library(survival)
library(multicenterCompRisk)
n_cov = 2
n_per_cluster = 20
n_cluster = 15
n = n_cluster * n_per_cluster
G = rep(1:n_cluster, each = n_per_cluster)
Z = matrix(rnorm(n*n_cov,0,1),ncol = n_cov)
df = simulate_data(G,Z,prop = 0.6,beta = c(1,1.2),theta = 0.3,cens = TRUE)
Parameters_estimation(df,method = "Cox_frailty")
Parameters_estimation(df,method = "Cox_frailty")
n_cov = 2
n_per_cluster = 20
n_cluster = 15
n = n_cluster * n_per_cluster
G = rep(1:n_cluster, each = n_per_cluster)
Z = matrix(rnorm(n*n_cov,0,1),ncol = n_cov)
df = simulate_data(G,Z,prop = 0.6,beta = c(1,1.2),theta = 0.3,cens = TRUE)
Parameters_estimation(df,method = "Cox_frailty")
n_cov = 2
n_per_cluster = 20
n_cluster = 15
n = n_cluster * n_per_cluster
G = rep(1:n_cluster, each = n_per_cluster)
Z = matrix(rnorm(n*n_cov,0,1),ncol = n_cov)
df = simulate_data(G,Z,prop = 0.6,beta = c(1,1.2),theta = 0.3,cens = TRUE)
Parameters_estimation(df,method = "Cox_frailty")
n_cov = 2
n_per_cluster = 20
n_cluster = 15
n = n_cluster * n_per_cluster
G = rep(1:n_cluster, each = n_per_cluster)
Z = matrix(rnorm(n*n_cov,0,1),ncol = n_cov)
df = simulate_data(G,Z,prop = 0.6,beta = c(1,1.2),theta = 0.3,cens = TRUE)
Parameters_estimation(df,method = "Cox_frailty")
devtools::load_all()
devtools::document()
devtools::document()
knitr::opts_chunk$set(echo = TRUE)
library(multicenterCompRisk)
library(tibble)
library(dplyr)
library(knitr)
library(kableExtra)
compute_mean_mse <- function(df, true_values) {
if (!is.data.frame(df)) stop("L'entrée doit être un data.frame.")
if (!is.numeric(true_values)) stop("true_values doit être un vecteur numérique.")
if (ncol(df) != length(true_values)) {
stop("Le nombre de colonnes du data.frame doit correspondre à la longueur de true_values.")
}
means <- colMeans(df, na.rm = TRUE)
true_mat <- matrix(rep(true_values, each = nrow(df)), nrow = nrow(df), byrow = FALSE)
mse <- colMeans((df - true_mat)^2, na.rm = TRUE)
result <- data.frame(
variable = colnames(df),
true_value = true_values,
mean = means,
mse = mse
)
return(result)
}
Multi_tests = function(N_test,
n_cov,
n_cluster,
n_per_cluster,
a1,
b1)
{
n = n_cluster * n_per_cluster
results <- data.frame(matrix(NA, nrow = N_test, ncol = (n_cov + 1)))
if (n_cov > 0) {
colnames(results) <- c(paste0("beta", 1:n_cov), "theta_hat")
} else{
colnames(results) <- "theta_hat"
}
for (i in 1:N_test)
{
G <- rep(1:n_cluster, each = n_per_cluster)
if (n_cov == 0) {
Z <- matrix(0, n, 0)
} else {
Z <- matrix(runif(n * n_cov, a1, b1), ncol = n_cov)
}
df = simulate_data(
G,
Z,
prop = 0.6,
beta = c(1,1.2),
theta = 0.2,
cens = TRUE,
pcens = 0.25,
tau = 0.5
)
ind <- which(df$status > 1)
df$status[ind] <- 1
df = data.frame(times = df$times,status = df$status,clusters = df$clusters,as.matrix(df[,4:(n_cov + 3)]))
res <- tryCatch(
Reml_Cox_frailty(df),
error = function(e) {
message("Erreur à l’itération ", i, " : ", e$message)
return(NULL)
}
)
if (!is.null(res)) {
if (n_cov > 0) {
results[i, 1:n_cov] <- res$beta
results[i, "theta_hat"] <- res$theta
} else{
results[i, "theta_hat"] <- res$theta
}
}
cat("itération", i, " sur ", N_test, "\n")
}
return(results)
}
M = Multi_tests(N_test = 20,n_cov = 2,n_cluster = 20,n_per_cluster = 15,a1 = 0,b1 = 1)
m = compute_mean_mse(M,c(1,1.2,0.2))
m
devtools::load_all()
knitr::opts_chunk$set(echo = TRUE)
library(multicenterCompRisk)
library(tibble)
library(dplyr)
library(knitr)
library(kableExtra)
Multi_tests = function(N_test,
n_cov,
n_cluster,
n_per_cluster,
a1,
b1)
{
n = n_cluster * n_per_cluster
results <- data.frame(matrix(NA, nrow = N_test, ncol = (n_cov + 1)))
if (n_cov > 0) {
colnames(results) <- c(paste0("beta", 1:n_cov), "theta_hat")
} else{
colnames(results) <- "theta_hat"
}
for (i in 1:N_test)
{
G <- rep(1:n_cluster, each = n_per_cluster)
if (n_cov == 0) {
Z <- matrix(0, n, 0)
} else {
Z <- matrix(runif(n * n_cov, a1, b1), ncol = n_cov)
}
df = simulate_data(
G,
Z,
prop = 0.6,
beta = c(1,1.2),
theta = 0.2,
cens = TRUE,
pcens = 0.25,
tau = 0.5
)
ind <- which(df$status > 1)
df$status[ind] <- 1
df = data.frame(times = df$times,status = df$status,clusters = df$clusters,as.matrix(df[,4:(n_cov + 3)]))
res <- tryCatch(
Reml_Cox_frailty(df),
error = function(e) {
message("Erreur à l’itération ", i, " : ", e$message)
return(NULL)
}
)
if (!is.null(res)) {
if (n_cov > 0) {
results[i, 1:n_cov] <- res$beta
results[i, "theta_hat"] <- res$theta
} else{
results[i, "theta_hat"] <- res$theta
}
}
cat("itération", i, " sur ", N_test, "\n")
}
return(results)
}
M = Multi_tests(N_test = 20,n_cov = 2,n_cluster = 20,n_per_cluster = 15,a1 = 0,b1 = 1)
m = compute_mean_mse(M,c(1,1.2,0.2))
m
devtools::load_all()
Multi_tests = function(N_test,
n_cov,
n_cluster,
n_per_cluster,
a1,
b1)
{
n = n_cluster * n_per_cluster
results <- data.frame(matrix(NA, nrow = N_test, ncol = (n_cov + 1)))
if (n_cov > 0) {
colnames(results) <- c(paste0("beta", 1:n_cov), "theta_hat")
} else{
colnames(results) <- "theta_hat"
}
for (i in 1:N_test)
{
G <- rep(1:n_cluster, each = n_per_cluster)
if (n_cov == 0) {
Z <- matrix(0, n, 0)
} else {
Z <- matrix(runif(n * n_cov, a1, b1), ncol = n_cov)
}
df = simulate_data(
G,
Z,
prop = 0.6,
beta = c(1,1.2),
theta = 0.2,
cens = TRUE,
pcens = 0.25,
tau = 0.5
)
ind <- which(df$status > 1)
df$status[ind] <- 1
df = data.frame(times = df$times,status = df$status,clusters = df$clusters,as.matrix(df[,4:(n_cov + 3)]))
res <- tryCatch(
Reml_Cox_frailty(df),
error = function(e) {
message("Erreur à l’itération ", i, " : ", e$message)
return(NULL)
}
)
if (!is.null(res)) {
if (n_cov > 0) {
results[i, 1:n_cov] <- res$beta
results[i, "theta_hat"] <- res$theta
} else{
results[i, "theta_hat"] <- res$theta
}
}
cat("itération", i, " sur ", N_test, "\n")
}
return(results)
}
M = Multi_tests(N_test = 20,n_cov = 2,n_cluster = 20,n_per_cluster = 15,a1 = 0,b1 = 1)
m = compute_mean_mse(M,c(1,1.2,0.2))
m
Multi_tests = function(N_test,
n_cov,
n_cluster,
n_per_cluster,
a1,
b1)
{
n = n_cluster * n_per_cluster
results <- data.frame(matrix(NA, nrow = N_test, ncol = (n_cov + 1)))
if (n_cov > 0) {
colnames(results) <- c(paste0("beta", 1:n_cov), "theta_hat")
} else{
colnames(results) <- "theta_hat"
}
for (i in 1:N_test)
{
G <- rep(1:n_cluster, each = n_per_cluster)
if (n_cov == 0) {
Z <- matrix(0, n, 0)
} else {
Z <- matrix(runif(n * n_cov, a1, b1), ncol = n_cov)
}
df = simulate_data(
G,
Z,
prop = 0.6,
beta = c(1,1.2),
theta = 0.6,
cens = TRUE,
pcens = 0.25,
tau = 0.5
)
ind <- which(df$status > 1)
df$status[ind] <- 1
df = data.frame(times = df$times,status = df$status,clusters = df$clusters,as.matrix(df[,4:(n_cov + 3)]))
res <- tryCatch(
Reml_Cox_frailty(df),
error = function(e) {
message("Erreur à l’itération ", i, " : ", e$message)
return(NULL)
}
)
if (!is.null(res)) {
if (n_cov > 0) {
results[i, 1:n_cov] <- res$beta
results[i, "theta_hat"] <- res$theta
} else{
results[i, "theta_hat"] <- res$theta
}
}
cat("itération", i, " sur ", N_test, "\n")
}
return(results)
}
M = Multi_tests(N_test = 20,n_cov = 2,n_cluster = 20,n_per_cluster = 15,a1 = 0,b1 = 1)
m = compute_mean_mse(M,c(1,1.2,0.6))
m
Multi_tests = function(N_test,
n_cov,
n_cluster,
n_per_cluster,
a1,
b1)
{
n = n_cluster * n_per_cluster
results <- data.frame(matrix(NA, nrow = N_test, ncol = (n_cov + 1)))
if (n_cov > 0) {
colnames(results) <- c(paste0("beta", 1:n_cov), "theta_hat")
} else{
colnames(results) <- "theta_hat"
}
for (i in 1:N_test)
{
G <- rep(1:n_cluster, each = n_per_cluster)
if (n_cov == 0) {
Z <- matrix(0, n, 0)
} else {
Z <- matrix(runif(n * n_cov, a1, b1), ncol = n_cov)
}
df = simulate_data(
G,
Z,
prop = 0.6,
beta = c(1,1.2),
theta = 0.6,
cens = TRUE,
pcens = 0.25,
tau = 0.5
)
ind <- which(df$status > 1)
df$status[ind] <- 1
df = data.frame(times = df$times,status = df$status,clusters = df$clusters,as.matrix(df[,4:(n_cov + 3)]))
res <- tryCatch(
Reml_Cox_frailty(df),
error = function(e) {
message("Erreur à l’itération ", i, " : ", e$message)
return(NULL)
}
)
if (!is.null(res)) {
if (n_cov > 0) {
results[i, 1:n_cov] <- res$beta
results[i, "theta_hat"] <- res$theta
} else{
results[i, "theta_hat"] <- res$theta
}
}
cat("itération", i, " sur ", N_test, "\n")
}
return(results)
}
M = Multi_tests(N_test = 200,n_cov = 2,n_cluster = 20,n_per_cluster = 15,a1 = 0,b1 = 1)
m = compute_mean_mse(M,c(1,1.2,0.6))
m
