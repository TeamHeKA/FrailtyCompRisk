n_per_cluster = 15
n_cluster = 20
n = n_cluster * n_per_cluster
G = rep(1:n_cluster, each = n_per_cluster)
Z = matrix(rnorm(n*n_cov,0,1),ncol = n_cov)
df = simulate_data(G,Z,prop = 0.6,beta = c(1,1.2),theta = 0.3,cens = TRUE)
res = Parameters_estimation(df,"CompRisk_frailty")
expect_equal(length(res$beta),n_cov)
expect_equal(length(res$theta),1)
expect_equal(length(res$u),n_cluster)
expect_lte(abs(res$beta[1]-1),1)
expect_lte(abs(res$beta[2]-1.2),1)
expect_lte(abs(res$theta - 0.3),1)
n_cov = 2
n_per_cluster = 15
n_cluster = 20
n = n_cluster * n_per_cluster
G = rep(1:n_cluster, each = n_per_cluster)
Z = matrix(rnorm(n*n_cov,0,1),ncol = n_cov)
df = simulate_data(G,Z,prop = 0.6,beta = c(1,1.2),theta = 0.3,cens = TRUE)
res = Parameters_estimation(df,"CompRisk")
expect_equal(length(res$beta), n_cov)
expect_lte(abs(res$beta[1] - 1), 1)
expect_lte(abs(res$beta[2] - 1.2), 1)
n_cov = 2
n_per_cluster = 15
n_cluster = 20
n = n_cluster * n_per_cluster
G = rep(1:n_cluster, each = n_per_cluster)
Z = matrix(rnorm(n * n_cov, 0, 1), ncol = n_cov)
df = simulate_data(G,Z,prop = 0.6,beta = c(1, 1.2),theta = 0.6,cens = TRUE)
res = Parameters_estimation(df, "Cox_frailty")
expect_equal(length(res$beta), n_cov)
expect_equal(length(res$theta), 1)
expect_equal(length(res$u), n_cluster)
expect_lte(abs(res$beta[1] - 1), 1)
expect_lte(abs(res$beta[2] - 1.2), 1)
expect_lte(abs(res$theta - 0.3), 1)
n_cov = 2
n_per_cluster = 15
n_cluster = 20
n = n_cluster * n_per_cluster
G = rep(1:n_cluster, each = n_per_cluster)
Z = matrix(rnorm(n*n_cov,0,1),ncol = n_cov)
df = simulate_data(G,Z,prop = 0.6,beta = c(1,1.2),theta = 0.3,cens = TRUE)
res = Parameters_estimation(df,"Cox")
expect_equal(length(res$beta),n_cov)
expect_lte(abs(res$beta[1]-1),1)
expect_lte(abs(res$beta[2]-1.2),1)
})
test_that("Parameters_estimation works", {
n_cov = 2
n_per_cluster = 15
n_cluster = 20
n = n_cluster * n_per_cluster
G = rep(1:n_cluster, each = n_per_cluster)
Z = matrix(rnorm(n*n_cov,0,1),ncol = n_cov)
df = simulate_data(G,Z,prop = 0.6,beta = c(1,1.2),theta = 0.3,cens = TRUE)
res = Parameters_estimation(df,"CompRisk_frailty")
expect_equal(length(res$beta),n_cov)
expect_equal(length(res$theta),1)
expect_equal(length(res$u),n_cluster)
expect_lte(abs(res$beta[1]-1),1)
expect_lte(abs(res$beta[2]-1.2),1)
expect_lte(abs(res$theta - 0.3),1)
n_cov = 2
n_per_cluster = 15
n_cluster = 20
n = n_cluster * n_per_cluster
G = rep(1:n_cluster, each = n_per_cluster)
Z = matrix(rnorm(n*n_cov,0,1),ncol = n_cov)
df = simulate_data(G,Z,prop = 0.6,beta = c(1,1.2),theta = 0.3,cens = TRUE)
res = Parameters_estimation(df,"CompRisk")
expect_equal(length(res$beta), n_cov)
expect_lte(abs(res$beta[1] - 1), 1)
expect_lte(abs(res$beta[2] - 1.2), 1)
n_cov = 2
n_per_cluster = 15
n_cluster = 20
n = n_cluster * n_per_cluster
G = rep(1:n_cluster, each = n_per_cluster)
Z = matrix(rnorm(n * n_cov, 0, 1), ncol = n_cov)
df = simulate_data(G,Z,prop = 0.6,beta = c(1, 1.2),theta = 0.6,cens = TRUE)
res = Parameters_estimation(df, "Cox_frailty")
expect_equal(length(res$beta), n_cov)
expect_equal(length(res$theta), 1)
expect_equal(length(res$u), n_cluster)
expect_lte(abs(res$beta[1] - 1), 1)
expect_lte(abs(res$beta[2] - 1.2), 1)
expect_lte(abs(res$theta - 0.3), 1)
n_cov = 2
n_per_cluster = 15
n_cluster = 20
n = n_cluster * n_per_cluster
G = rep(1:n_cluster, each = n_per_cluster)
Z = matrix(rnorm(n*n_cov,0,1),ncol = n_cov)
df = simulate_data(G,Z,prop = 0.6,beta = c(1,1.2),theta = 0.3,cens = TRUE)
res = Parameters_estimation(df,"Cox")
expect_equal(length(res$beta),n_cov)
expect_lte(abs(res$beta[1]-1),1)
expect_lte(abs(res$beta[2]-1.2),1)
})
devtools::load_all()
devtools::check()
knitr::opts_chunk$set(echo = TRUE)
library(multicenterCompRisk)
library(tibble)
library(dplyr)
library(knitr)
library(kableExtra)
compute_mean_mse <- function(df, true_values) {
if (!is.data.frame(df)) stop("L'entrée doit être un data.frame.")
if (!is.numeric(true_values)) stop("true_values doit être un vecteur numérique.")
if (ncol(df) != length(true_values)) {
stop("Le nombre de colonnes du data.frame doit correspondre à la longueur de true_values.")
}
means <- colMeans(df, na.rm = TRUE)
true_mat <- matrix(rep(true_values, each = nrow(df)), nrow = nrow(df), byrow = FALSE)
mse <- colMeans((df - true_mat)^2, na.rm = TRUE)
result <- data.frame(
variable = colnames(df),
true_value = true_values,
mean = means,
mse = mse
)
return(result)
}
Multi_tests = function(N_test,
n_cov,
n_cluster,
n_per_cluster,
a1,
b1)
{
n = n_cluster * n_per_cluster
results <- data.frame(matrix(NA, nrow = N_test, ncol = (n_cov)))
if (n_cov > 0) {
colnames(results) <- paste0("beta", 1:n_cov)
} else{
stop("Covariables missing")
}
for (i in 1:N_test)
{
G <- rep(1:n_cluster, each = n_per_cluster)
if (n_cov == 0) {
Z <- matrix(0, n, 0)
} else {
Z <- matrix(runif(n * n_cov, a1, b1), ncol = n_cov)
}
df = simulate_data(
G,
Z,
prop = 0.6,
beta = c(0, 0.25, 0.12, 0.33, 0.24, 1, -0.2, -0.35),
theta = 0,
cens = TRUE,
pcens = 0.25,
tau = 0.5
)
df = data.frame(times = df$times, status = df$status,clusters = rep(1,length(G)),as.matrix(df[,4:(n_cov + 3)]))
ind <- which(df$status > 1)
df$status[ind] <- 1
res <- tryCatch(
Ml_Cox(df),
error = function(e) {
message("Erreur à l’itération ", i, " : ", e$message)
return(NULL)
}
)
if (!is.null(res)) {
if (n_cov > 0) {
results[i, 1:n_cov] <- res$beta
}
}
cat("itération", i, " sur ", N_test, "\n")
}
return(results)
}
M = Multi_tests(N_test = 100,n_cov = 8,n_cluster = 20,n_per_cluster = 25,a1 = 0,b1=1)
m = compute_mean_mse(M, c(0, 0.25, 0.12, 0.33, 0.24, 1, -0.2, -0.35))
m
m = compute_mean_mse(M,c(1,1.2,0,-0.5,0.6))
Multi_tests = function(N_test,
n_cov,
n_cluster,
n_per_cluster,
a1,
b1)
{
n = n_cluster * n_per_cluster
results <- data.frame(matrix(NA, nrow = N_test, ncol = (n_cov + 1)))
if (n_cov > 0) {
colnames(results) <- c(paste0("beta", 1:n_cov), "theta_hat")
} else{
colnames(results) <- "theta_hat"
}
for (i in 1:N_test)
{
G <- rep(1:n_cluster, each = n_per_cluster)
if (n_cov == 0) {
Z <- matrix(0, n, 0)
} else {
Z <- matrix(runif(n * n_cov, a1, b1), ncol = n_cov)
}
df = simulate_data(
G,
Z,
prop = 0.6,
beta = c(1,1.2,0,-0.5),
theta = 0.6,
cens = TRUE,
pcens = 0.25,
tau = 0.5
)
if (n_cov > 0){
X = as.matrix(df[,4:(n_cov + 3)])}
else{
X = matrix(0,nrow = n,ncol = 0)}
ind <- which(df$status > 1)
df$status[ind] <- 1
df = data.frame(times = df$times,status = df$status,clusters = df$clusters,X)
res <- tryCatch(
Reml_Cox_frailty(df),
error = function(e) {
message("Erreur à l’itération ", i, " : ", e$message)
return(NULL)
}
)
if (!is.null(res)) {
if (n_cov > 0) {
results[i, 1:n_cov] <- res$beta
results[i, "theta_hat"] <- res$theta
} else{
results[i, "theta_hat"] <- res$theta
}
}
cat("itération", i, " sur ", N_test, "\n")
}
return(results)
}
M = Multi_tests(N_test = 50,n_cov = 4,n_cluster = 20,n_per_cluster = 15,a1 = 0,b1 = 1)
m = compute_mean_mse(M,c(1,1.2,0,-0.5,0.6))
m
Multi_tests = function(N_test,
n_cov,
n_cluster,
n_per_cluster,
a1,
b1)
{
n = n_cluster * n_per_cluster
results <- data.frame(matrix(NA, nrow = N_test, ncol = (n_cov)))
if (n_cov > 0) {
colnames(results) <- paste0("beta", 1:n_cov)
} else{
stop("Covariables missing")
}
for (i in 1:N_test)
{
G <- rep(1:n_cluster, each = n_per_cluster)
if (n_cov == 0) {
Z <- matrix(0, n, 0)
} else {
Z <- matrix(runif(n * n_cov, a1, b1), ncol = n_cov)
}
df = simulate_data(
G,
Z,
prop = 0.6,
beta = c(0, 0.25, 0.12, 0.33, 0.24, 1, -0.2, -0.35),
theta = 0,
cens = TRUE,
pcens = 0.25,
tau = 0.5
)
df = data.frame(times = df$times, status = df$status, clusters = rep(1,length(G)), as.matrix(df[,4:(n_cov + 3)]))
res <- tryCatch(
Ml_CompRisk(df),
error = function(e) {
message("Erreur à l’itération ", i, " : ", e$message)
return(NULL)
}
)
if (!is.null(res)) {
if (n_cov > 0) {
results[i, 1:n_cov] <- res$beta
}
}
cat("itération", i, " sur ", N_test, "\n")
}
return(results)
}
M = Multi_tests(N_test = 100,n_cov = 8,n_cluster = 20,n_per_cluster = 25,a1 = 0,b1 = 1)
m = compute_mean_mse(M, c(0, 0.25, 0.12, 0.33, 0.24, 1, -0.2, -0.35))
m
Multi_tests = function(N_test,
n_cov,
n_cluster,
n_per_cluster,
a1,
b1)
{
n = n_cluster * n_per_cluster
results <- data.frame(matrix(NA, nrow = N_test, ncol = (n_cov + 1)))
if (n_cov > 0) {
colnames(results) <- c(paste0("beta", 1:n_cov), "theta_hat")
} else{
colnames(results) <- "theta_hat"
}
for (i in 1:N_test)
{
G <- rep(1:n_cluster, each = n_per_cluster)
if (n_cov == 0) {
Z <- matrix(0, n, 0)
} else {
Z <- matrix(runif(n * n_cov, a1, b1), ncol = n_cov)
}
df = simulate_data(
G,
Z,
prop = 0.6,
beta = c(0, 0.25, 0.12, 0.33, 0.24, 1, -0.2, -0.35),
theta = 0.6,
cens = TRUE,
pcens = 0.25,
tau = 0.5
)
check_data_format(df)
res <- tryCatch(
Reml_CompRisk_frailty(df, max_iter = 100),
error = function(e) {
message("Erreur à l’itération ", i, " : ", e$message)
return(NULL)
}
)
if (!is.null(res)) {
if (n_cov > 0) {
results[i, 1:n_cov] <- res$beta
results[i, "theta_hat"] <- res$theta
} else{
results[i, "theta_hat"] <- res$theta
}
}
cat("itération", i, " sur ", N_test, "\n")
}
return(results)
}
M = Multi_tests(N_test = 50,n_cov = 8,n_cluster = 100,n_per_cluster = 250,a1 = 0,b1 = 1)
Multi_tests = function(N_test,
n_cov,
n_cluster,
n_per_cluster,
a1,
b1)
{
n = n_cluster * n_per_cluster
results <- data.frame(matrix(NA, nrow = N_test, ncol = (n_cov + 1)))
if (n_cov > 0) {
colnames(results) <- c(paste0("beta", 1:n_cov), "theta_hat")
} else{
colnames(results) <- "theta_hat"
}
for (i in 1:N_test)
{
G <- rep(1:n_cluster, each = n_per_cluster)
if (n_cov == 0) {
Z <- matrix(0, n, 0)
} else {
Z <- matrix(runif(n * n_cov, a1, b1), ncol = n_cov)
}
df = simulate_data(
G,
Z,
prop = 0.6,
beta = c(0, 0.25, 0.12, 0.33, 0.24, 1, -0.2, -0.35),
theta = 0.6,
cens = TRUE,
pcens = 0.25,
tau = 0.5
)
View(df)
check_data_format(df)
res <- tryCatch(
Reml_CompRisk_frailty(df, max_iter = 100),
error = function(e) {
message("Erreur à l’itération ", i, " : ", e$message)
return(NULL)
}
)
if (!is.null(res)) {
if (n_cov > 0) {
results[i, 1:n_cov] <- res$beta
results[i, "theta_hat"] <- res$theta
} else{
results[i, "theta_hat"] <- res$theta
}
}
cat("itération", i, " sur ", N_test, "\n")
}
return(results)
}
M = Multi_tests(N_test = 50,n_cov = 8,n_cluster = 100,n_per_cluster = 250,a1 = 0,b1 = 1)
Multi_tests = function(N_test,
n_cov,
n_cluster,
n_per_cluster,
a1,
b1)
{
n = n_cluster * n_per_cluster
results <- data.frame(matrix(NA, nrow = N_test, ncol = (n_cov + 1)))
if (n_cov > 0) {
colnames(results) <- c(paste0("beta", 1:n_cov), "theta_hat")
} else{
colnames(results) <- "theta_hat"
}
for (i in 1:N_test)
{
G <- rep(1:n_cluster, each = n_per_cluster)
if (n_cov == 0) {
Z <- matrix(0, n, 0)
} else {
Z <- matrix(runif(n * n_cov, a1, b1), ncol = n_cov)
}
df = simulate_data(
G,
Z,
prop = 0.6,
beta = c(0, 0.25, 0.12, 0.33, 0.24, 1, -0.2, -0.35),
theta = 0.6,
cens = TRUE,
pcens = 0.25,
tau = 0.5
)
View(df)
check_data_format(df)
res <- tryCatch(
Reml_CompRisk_frailty(df, max_iter = 100),
error = function(e) {
message("Erreur à l’itération ", i, " : ", e$message)
return(NULL)
}
)
if (!is.null(res)) {
if (n_cov > 0) {
results[i, 1:n_cov] <- res$beta
results[i, "theta_hat"] <- res$theta
} else{
results[i, "theta_hat"] <- res$theta
}
}
cat("itération", i, " sur ", N_test, "\n")
}
return(results)
}
M = Multi_tests(N_test = 50,n_cov = 8,n_cluster = 15, n_per_cluster = 20,a1 = 0,b1 = 1)
devtools::install()
library(multicenterCompRisk)
Multi_tests = function(N_test,
n_cov,
n_cluster,
n_per_cluster,
a1,
b1)
{
n = n_cluster * n_per_cluster
results <- data.frame(matrix(NA, nrow = N_test, ncol = (n_cov + 1)))
if (n_cov > 0) {
colnames(results) <- c(paste0("beta", 1:n_cov), "theta_hat")
} else{
colnames(results) <- "theta_hat"
}
for (i in 1:N_test)
{
G <- rep(1:n_cluster, each = n_per_cluster)
if (n_cov == 0) {
Z <- matrix(0, n, 0)
} else {
Z <- matrix(runif(n * n_cov, a1, b1), ncol = n_cov)
}
df = simulate_data(
G,
Z,
prop = 0.6,
beta = c(0, 0.25, 0.12, 0.33, 0.24, 1, -0.2, -0.35),
theta = 0.6,
cens = TRUE,
pcens = 0.25,
tau = 0.5
)
View(df)
check_data_format(df)
res <- tryCatch(
Reml_CompRisk_frailty(df, max_iter = 100),
error = function(e) {
message("Erreur à l’itération ", i, " : ", e$message)
return(NULL)
}
)
if (!is.null(res)) {
if (n_cov > 0) {
results[i, 1:n_cov] <- res$beta
results[i, "theta_hat"] <- res$theta
} else{
results[i, "theta_hat"] <- res$theta
}
}
cat("itération", i, " sur ", N_test, "\n")
}
return(results)
}
M = Multi_tests(N_test = 50,n_cov = 8,n_cluster = 15, n_per_cluster = 20,a1 = 0,b1 = 1)
